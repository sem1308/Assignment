# 클라이언트 서버 통신
-------------------------------------------------------
  * 기본 통신 방법
  
    * 서버가 먼저 실행상태가 되어 클라이언트 섭속 기다림
    * 클라이언트는 서버의 서비스를 이용하기 위해 request를 보내고 서버로부터 response를 기다림
    * 서버는 클라이언트의 접속을 받아 서비스를 제공할 유효한 대상인지 확인
    * 클라이언트는 서버의 서비스를 받아 처리 
 ------------------------------------------------------
  C/S 통신모델의 종류
  ------------------------------------------------------
  * 연결형과 비연결형 서버
  
      * 연결형: [TCP](https://github.com/sem1308/Assignment/blob/master/Documents/TCP.md)와 같은 연결형 프로토콜 사용
        * 데이터의 안정적인 전달 보장
        * 모든 클라이언트와의 접속마다 소켓을 각각 개설하고 있어야 함(단, 많이 개설하면 비용이 많이 듬)
      * 비연결형: [UDP](https://github.com/sem1308/Assignment/blob/master/Documents/UDP.md)와 같은 비연결 프로토콜 사용
        * 안정적인 데이터 전달을 책임지지 못하므로 테이터유효성 체크를 프로그램해야함
        * 메시지를 한번만 보내면 되는 간단한 서비스에 적합
        * 클라이언트마다 연결설정 할 필요 없음
        * 방송형, 멀티캐스팅형 서비스에 적합 
   -------------------------------------------------------
  * stateful과 stateless 서버
  
      - stateful : 서버가 클라이언트의 통신 상태를 계속 추적하며 관리하는 서버.
        * 상태 : 연결설정, 데이터 송수신, 오루발생등 과거의 통신 처리 결과
        * 현재 상태에 따라 신속히 응답할 수 있으며 클라이언트와의 메시지 정보의양 줄일 수 있음.
        * 모든 클라이언트와의 접속마다 상태정보를 각각 보유하고 있어야 함
        * 틀린 정보를 통신에 사용할 가능성이 있음.
        * telnet, ftp 서버
      - stateless : 상태정보를 정의하지 않고 항상 클라이언트로의 독립된 request에 의해 서비스를 제공하는 서버
        * 전송정보로써 틀린정보를 사용할 가능성이 적음.
        * 상태정보를 기억하지 않으므로 메시지 마다 상태정보를 전송해야 함.
        * 회선이 안정적이 않은 환경에서 사용하면 유리
        * 웹 서버
   -------------------------------------------------------
  * Iterative와 Concurrent 서버
  
      * Iterative : 클라이언트의 서비스 요구를 순서대로 처리해주는 서버
        * 하나의 프로세스가 모든 클라이언트의 서비스를 처리
        * 구현이 비교적 간단.
        * 서비스의 처리 시간이 짧은 경우에 사용
        * 한 클라이언트의 요구 처리가 끝날 때 까지 다른 클라이언트 요구는 처리 못함.
      * Concurrent : 여러 클라이언트의 요구를 모았다가 동시에 서비스를 제공하는 서버
        * 각 클라이언트에 대해 프로세스가 하나씩 생성
         (한 프로세스가 몇개의 클라이언트를 처리하도록 설계하기도 함.)
        * 서버 구현이 비교적 복잡함.
         서비스의 처리 시간이 긴 경우에 사용

    
    

